\documentclass[oneside]{book}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{color}
\usepackage{multicol}
\usepackage{ragged2e}
\usepackage{listings}
\usepackage{pdfpages}
\title{Notes de Cours INF 3610}
\date{2018-10-10}
\author{Olivier Sirois}
\setlength\parindent{0pt}
\makeindex
\pagenumbering{arabic}
\begin{document}
    \setcounter{page}{1}
    \maketitle
    \tableofcontents
    \chapter{Chapitre 1 - Introduction}
    On peu définir la vérification formelle comme étant l'utilisation de techniques théorique pour prouver le fonctionnement d'un système. Selon Sommerville, la vérification est la réponse à la question:\\
    %%\centering
    \textbf{Are we building the product right}\\
    
    Pour etre vérifié, un système doit satisfaire:
    \begin{itemize}
        \item Vérification formele complète : exploration de façon exhaustive de tous les états possible du système
        \item Vérification formelle incomplète : vérification des bornes
    \end{itemize}

    INSÉRÉ PHOTO PROCESSUS DE DÉVELOPPEMENT\\
    On vérifie formellement pour renforcer le processus de développement. Les techniques de vérification peuvent s'appliquer à différent niveau, car on regarde seulement le fonctionne du module sous test, pas tous le système.\\
    
    INSÉRÉ PHOTO DES TESTS (MICROSCOPE)\\
    
    On voit sur la photo la différence entre les deux méthodes de vérification, une est applicable à un gros système vs. l'autre qui ne peut être fait que sur des éléments de petites tailles.\\
    
    Évidemment, certains accidents notables peuvent être attribuer à un manque de vérification. sa peut aller de AT\&T à la NASA. (problème d'inversion).\\
    
    Lorsqu'on fait affaire dans des systèmes critiques, soit:
    \begin{itemize}
        \item Transport (avionique, ferroviaire, spatial)
        \item Energie (nuclearire...)
        \item Medical (dosage radioactif)
    \end{itemize}

    En raison de la criticalités de ces applications, certains documents ont été mis en place pour la production de logiciel pour les applications aéronautiques.\\
    
    Les normes ED-12C et DO-178C précisent ces contraintes.\\
    
    \subsection{Comment vérifier formellement}
    \begin{itemize}
        \item Modéliser
        \item Spécifier
        \item Prouver
    \end{itemize}

    INSÉRÉ PHOTOS SLIDE 22\\
    
    \subsection{Comment spécifier un comportement}
    Le but de la modélisation est d'expirmer, au moyen d'un formalisme la manière dont le système se comporte. Le formalisme doit être assez expressif, repose sur une sémantique rigoureuse et doit offrire des possibilités d'analyse systématique. On peut résumé sa en une représentation simplifiée d'un système.\\
    
    Dans le cas des systèmes temps réelles, le fonctionnement est assujetti à l'évolution dynamique de l'environnement et la réaction aux stimuli est soumise à des contraintes temporelles. c-a-d, il faut que la réponse à l'environnement arrive dans un temps spécifier. Plusieurs modèle formels ont été développés puis adaptés aux systèmes temps réel. On peut les distingué par la séquentialité (concurrence), le non-déterminisme, la synchronisation, la communication, la compositionnalité, les contraintes temporelles. On a même certains language de spécifications fait pour pouvoir vérifier des sytèmes.\\
    
    les classe de modèles proposé dans la litérature sont :
    \begin{itemize}
        \item langage de prog..
    \end{itemize}
    
    INSÉRÉ SLIDE 27\\
    
    en générales, les modèles doivent spécifier les:
    \begin{itemize}
        \item actions
        \item événement,
        \item contraintes,
        \item conditions d'activation,
        \item situations anormale et 
        \item les états significatifs
    \end{itemize} 

    langage de prog -> séparer en deux partie:
    \begin{itemize}
        \item classique, JAVA, C, C++
        \item ceux basé sur un modele de transition, RT-LOTOS, PROMELA, ESTEREL, LUSTRE
    \end{itemize}
    
    \subsection{JAVA}
    
    Java pathfinder, vérificateur (model-checker) pour la NASA. (babelfish). \\
    
    INSÉRÉ PHOTO  SLIDE 32\\
    
    \subsection{LLBMC - low level bounded model checker}
    travail sur un code bas niveau (assembleur?). il fait du bounded model-checking dépendament du domaine spécifier.\\
    
    INSÉRÉ SLIDE 34\\
    
    \subsection{Promela, model-checker SPIN}
    Promela (protocol/process meta language) est utilisé par le model checker SPIN. cré dynamiquement des processus concurrents, la communication entre processus via des variables partagées et des canaux de messages\\
    
    INSÉRÉ SLIDE 36\\
    
    \subsection{LUSTRE, (boite a outils SCADE)}
    language synchrone a flots de donnees. Sa permet d'exprimer un systeme sour forme d'équations qui définissent l'évolution des valeurs de ses varables\\
    
    INSÉRÉS SLIDE 38\\
    
    on peut spécifier un programme aussi comme sur la slide 39\\
    
    \subsection{Modele a base de transition}
    On simule une sorte de state machine mealy, ou on modélise les états discrèt par états ainsi que leur transitions par rapport à leurs actions\\
    
    Ces modèles sont en générales graphique:
    \begin{itemize}
        \item Les Statecharts
        \item Les réseaux de Petri
        \item Les automates
    \end{itemize}

    Les automates offrent un bon compromis entre la puissance de modélisation et la complexité de vérification\\
    
    INSÉRÉ SLIDE 44, 45, 46\\
    
    \subsection{Modeles Logiques}
    
    INSÉRÉ SLIDE 48\\
    
    \subsection{Modèles Algébrique}
    
    Description du comportement d'un système à l'aide d'une description algébrique. On combine des opérateurs et des actions.\\
    
    INSÉRÉS SLIDE 50\\
    
    \subsection{Comment spécifier une proprité}
    On peut utiliser la logique (propositionelle, prédicat), pour spécifier des chose. Sauf que c'étais insuffisant pour décrire des systèmes à comportement temporels. On a alors étendu ces notions à logique temporelle pour pouvoir vérifier formellement des systèmes de natures temporelle.\\
    
    INSÉRÉS SLIDE 54\\
    
    \subsection{Logique temporelle linéaire}
    LTL permet d'expliquer comme la logique évolue dans le temps\\
    
    \subsection{Logique temporelle arborescente (CTL)}
    Cette logique permet de quantifier les chemins d'exécutions\\
    
    INSÉRÉS SLIDE 56\\
    
    \subsection{Vérification effective}
    La vérification est dite décidable pour un ensemble de modèles M et une classe de propriétés P si et seulement si il existe un programme qui prend en trné un modèle quelconque de M et une propriété quelconque de P et détermine au bout d'un temps fini, si la propriété est satisfaite ou non par le modèle. Pour être automatisable, la vérification doit être décidable et aussi de complexité acceptable. On différencier entre deux grandes catégories de méthodes: les méthodes syntaxiques et les méthodes sémantiques.\\
    
    \subsection{Méthodes syntaxiques}
    Ce sont des preuves au sens mathématique du terme. Elles cherchent à déterminer si une propriété peut être obtenus.. difficile a automatiser\\
    
    INSÉRÉ SLIDES 61\\
    
    Pour résoudre syntaxiquement, on utilise les méthodes vu dans le cours 8215 (logique prédicats/propositionelle)\\
    
    \subsection{Méthodes sémantiques}
    Dans les méthodes sémantiques, on se base sur l'exécution du modèle. L'approche populaire est le model-checking. Sa s'appuie sur deux formalisme:
    \begin{itemize}
        \item système de transition
        \item logique temporelle
    \end{itemize}

    INSÉRÉ SLIDES 65\\
    
    \subsection{Model-checking}
    Normalement automatique, et produit des contrexemple sous forme de traces qui sont utils à la compréhension des situations d'erreurs et àla correction. basé sur la sémantique d'entrelacement, avec sa, sa pourrait générer n! et plus de $2^{n}$ états\\
    
    Gros problème d'explosion combinatoire avec sa..\\
    
    \chapter{Cours 2 - Automate temporisé}
    \section{Introduction}
    \paragraph{Systèmes temps réel} Agit dans l'environnement.. \\
    INSÉRÉ SLIDE 3\\
    
    Normalement, le systèmes captes son environnement à l'aide de \textbf{capteurs}, fait des traitements (normalement dans un temps définis) et agit ensuite dans son environnement à l'aide d'\textbf{actuateurs}.\\
    
    Le principe est que dans un système temps réel, on doit répondre dans un temps requis. La vérification de tels systèmes doivent alors prendre en considération les contraintes temporelles.\\
    \begin{itemize}
        \item Statecharts, réseaux de pétri temporisé, Automates temporisés
        \item Algèbre de processus temporisé
        \item language synchrone
    \end{itemize}
    \textbf{Automates temporisé}: offrent un très bon compromis entre la puissnace de modélisation et la complexité de vérification.\\
    
    INSÉRÉ SLIDE 5\\
    
    De plus, on ne peut pas se contenter de simplement modéliser le System under test, on doit aussi modéliser l'environnement et ses interactions avec le systèmes testé.\\
    
    \section{Automates}
    un automate est un tuple A = < L, Act, E, I0> ou:
    \begin{itemize}
        \item L est un ensemle fini et non vide de sommets (locations)
        \item Act est un ensemble fini d'actions pour le sommet
        \item E $\in$ L x Act x L est un ensemble fini de transition possible (transitions)
        \item I0 est 'état initiale
    \end{itemize}

    INSÉRÉ SLIDE 7
    
    d'un automate, on peut extraite un évolution. Qui est une séquence alterné d'états et d'actions. Il est possible de déduire les évolutions possible du modèles. On appelle trace d'exécution la séquence d'action exécutées selon une évolution. ex: action1 -> action2 -> action3.\\
    
    Avec deux automates, leurs composition est le produit scalaire entre les deux automates.\\
    
    INSÉRÉ SLIDE 9, 10\\
    
    représentent le produit entre deux automates. Il prend en compte des actions des deux automates (synchronisation) versus les actions locals à chaque automates.\\
    
    
    
    
    \section{Automates Temporisé}
    On peutrajouter des contraints temporelles. Lorsqu'un message m est émis, m est déclaré perdu si aucun acquitetement n'est recu avant les 5 unités de temps qui suivent l'émission et un acquittement ne peut être recu qu'après 1 unité de temps.\\
    
    Le modèle d'automates temporisé est une extension du modèle d'automates traditionelle qui prend en considération ces contraintes temporelles.\\
    
    On distingue deux sémantiques pour le domaine temporel. on peut le faire en temps discret ou en temps continue. Normalement on vérifie les systèmes en temps continue parce qu'il n'y a aucune fréquence d'échantillonage qui peut théoriquement attraper toute les différentes possibilité d'arrivé d'événement.\\
    
    On associe normalement des horloges (qui sont les seules variables continus). Les horloges évoluent de facon uniforme avec le temps. Elle peut être mise à zéro au franchissement d'un arc pour commencer à compter le temps à partir d'un événement bien précis.\\
    
    INSÉRÉ SLIDE 14\\
    
    Il suffit d'imposer des contraintes sur les horloges pour modéliser les aspect temporelles des automates.\\
    
    Noter que d'avoir un horloge sur un état signifie qu'on a une contrainte pour rester dans un état. l'absence d'horloge signifie qu'il n'y a aucune limites de temps.\\
    
    Une évolution d'un automate temporisé est une séquence alterné d'états et d'actions continues-discrètes.\\
    
    INSÉRÉ SLIDE 15 (BAS)\\
    
    On peut définir une contrainte temporelle par la grammaire de la slide 16\\
    
    INSÉRÉ TOP SLIDE 16\\
    
    ou x et y sont des horloge, c est un entier et $\angle$$\in$\{$\le$, $\leq$\}\\
    
    INSÉRÉ BAS DE SLIDE 16\\
    
    
    \subsection{Contraintes temporelles}
    Soit un ensemble fini d'horloge\\
    
    une valuation v de H est une fonction qui associe à chaque horloge de H une valeur réelle positive ou nulle. $R^{+}$.\\
    
    soit F une contrainte temporelle sur H et v une valuation de H, dh $\in$ $R^+$ et $H' \in H $\\
    
    INSÉRÉ BAS SLIDE 17\\
       
    INSÉRÉ ÉQUATION DE SLIDE 18\\
    
    \subsubsection{Exemple}
    INSÉRÉ SLIDE 19\\
    
    \begin{itemize}
        \item 
        \textbf{f1 est-elle consistante?} \\
        Le contraintes sont rencontrés dans f1 et f2. Alors c'est consistant\\
         v(x) = v(y) = 2\\
         v(x) = v(y) = v(2) = 2
         
        \item 
        \textbf{Donnez la représentation graphique}\\
         x est compris parmis les bornes. On doit faire les contraintes vertical/horizontal pour x et y. On rajoute ensuite les contraintes diagonale.\\
         
        
        
        
    \end{itemize}
    
    \subsection{Définition et représentation graphique}
    Pour une représentation graphique, on  modifie une condition d'un automate \\
    
    INSÉRÉ Définition SLIDE 20\\
    
    On défini Inv comme étant l'invariant. Elle associe une contrainte temporelle applée L à chaque sommet. Inv(l) doit être fermée en arrière.\\
    
    $\forall$ $\in$ L, v $\in$V, dH $\in$...\\
    
    INSÉRÉ SLIDE 21, 22, 23, 24\\
    Le principe est que certaine formulation d'invariant peuvent donner des comportements inattendus.\\
    
    Un état du modèle est défini par un couple composé d'un sommet I et d'une valuation v des horloges de H qui satisfait Inv(I), i.e.: Inv(l)(v) est vraie.\\
    
    on peut seulement prendre une transition si la valuation de sa transition est vraie.\\
    
    
    
    \subsection{Sémantique opérationelle}    
    
    Un système de trnaisitions est un tuple T <Q, $Q_0$, Et, Rt>\\
    \begin{itemize}
        \item Q est un ensemble non vide d'états
        \item Et est un ensemble d'étiquettes
        \item Rt est une relation de transitions entre les états
        \item Q0 est un ensemble d'états initiaux
    \end{itemize}

    INSÉRÉ SLIDE 27 (PROPRIÉTÉTS)\\
    
    Le système de transitions d'un automate temporisé\\
    
    A = <L, H, Act, E, I0, Inv>\\
    
    INSÉRÉ PROPRIÉTÉ SLIDE 28\\
    
    INSÉRÉ SLIDE 29\\
    
    INSÉRÉ SLIDE 30\\
    Note, il n'existe pas d'évolution qui supporte ABA vu que l'invariant de l1 éjecte en dehors de l1 à x$\geq$2\\
    
    \subsection{Automates bien temporisés}
    
    Une évolution inif est à temps divergent si la somme des temps de séjours dans ses locations est infinis, convergent quand ses finis.\\
    
    \subsubsection{Temps convergent et zénon}
    INSÉRÉ SLIDE 32\\
    
    la suite peu avoir une infinité d'actions, sauf que l'invariant de on ne supporte pas une valeur d'horloge en haut de 2.\\
    
    Pour un non-zénon, dans tout cycle élémentaire de transitions discrète au moins une horloge est remise à zéro et comparé à une orne inférieur strictement positive.\\
    
    INSÉRÉ SLIDE 33\\
    
    un état a un verrou temporel (timelock) si il n'a aucune évolution à temps divergent \\
    
    dans la deuxième image, aucune possibilité d'été pour une valeur de x supérieur à 2\\
    
    Un automate temporisé est à l'état bloqué si aucune action de Act ne peut être exécuté à partir de cet état (état bloqué).\\
    
    un automate est bien temporisé si: pour chaque état accessible q (l,v) il existe une action a de Act ou un réel positif dh tel que \\
    
    INSÉRÉ IMAGE SLIDE 34\\
    
    et il est non zénon (toutes ses évolutions sont non zénon).
    \section{Composition d'automates temporisé}
    
    INSÉRÉ SLIDE 35\\
    
    On fait comme au début du cours, on fait l'union des actions, horloge et états.. c'est gros.\\
    
    Les composition d'automates se généralise à un ensemble  d'automate..\\
    
    Pour synchroniser deux automates, il faut tout simplement mettre la même actions.\\
    
    
    \section{Automate temporisé à la UPPAAL}
    \section{Automates hybride, à chronomêtre, à couts}
    
\end{document}